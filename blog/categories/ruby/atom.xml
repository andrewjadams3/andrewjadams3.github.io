<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Andrew Adams]]></title>
  <link href="http://andrewada.ms/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://andrewada.ms/"/>
  <updated>2014-09-23T14:44:25-05:00</updated>
  <id>http://andrewada.ms/</id>
  <author>
    <name><![CDATA[Andrew Adams]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Linked Lists]]></title>
    <link href="http://andrewada.ms/blog/2014/linked-lists/"/>
    <updated>2014-09-23T10:38:55-05:00</updated>
    <id>http://andrewada.ms/blog/2014/linked-lists</id>
    <content type="html"><![CDATA[<p>Something that I wished I had learned more about during my time at <a href="http://devbootcamp.com">Dev Bootcamp</a> was how to construct basic data structures. I know, it sounds fairly boring, and maybe even unnecessary for day-to-day web development, but I&rsquo;ve always been curious as to what&rsquo;s going on behind the scenes when I instantiate or modify something like a hash.</p>

<p>Luckily for me, <a href="https://twitter.com/dastels">Dave Astels</a> has been volunteering his time at DBC to teach students how to implement data structures from the ground up. Recently, Dave held a class on linked lists which I found to be incredibly fun and informative. In fact, it inspired me to learn as much as I can about data structures during my job search. I&rsquo;m excited to share with you some of what I&rsquo;ve learned about linked lists so far, and maybe even convince you to find ways to implement them yourself!</p>

<!-- more -->


<p>At a basic level, a linked list is a series of nodes with each node referencing the next in the series. Based on this description, we can start to map out what classes we&rsquo;ll need to build our own. A <code>Node</code> class is pretty much a given (we&rsquo;ll call ours <code>ListNode</code>), but we&rsquo;ll also need a class that&rsquo;s able to keep track of which node is at the head of the list (as well as the ability to modify the list of nodes). We&rsquo;ll call this our <code>LinkedList</code>.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">LinkedList</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">head</span><span class="o">=</span><span class="kp">nil</span><span class="p">)</span><span class="o">&lt;</span><span class="sr">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;pre&gt;&lt;code&gt;@head = head</span>
</span><span class='line'><span class="sr">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;</span><span class="sr">/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt;  end</span>
</span><span class='line'><span class="sr">end&lt;/</span><span class="nb">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nb">p</span><span class="o">&gt;</span><span class="k">class</span> <span class="nc">ListNode</span>
</span><span class='line'>  <span class="kp">attr_reader</span> <span class="ss">:value</span><span class="p">,</span> <span class="ss">:rest</span><span class="o">&lt;</span><span class="sr">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt;  def initialize(value, rest=nil)&lt;/</span><span class="nb">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="vi">@value</span> <span class="o">=</span> <span class="n">value</span>
</span><span class='line'><span class="vi">@rest</span> <span class="o">=</span> <span class="n">rest</span>
</span><span class='line'><span class="o">&lt;</span><span class="sr">/code&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nb">p</span><span class="o">&gt;</span>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>You&rsquo;ll notice that our <code>ListNode</code> is instantiated with <code>@value</code> and <code>@rest</code>. <code>@value</code> is what the node represents, and can be any generic data type (such as a <code>String</code> or <code>Integer</code>). <code>@rest</code> can eventually reference another node, but is initialized as <code>nil</code> (meaning that it is the final node in the list).</p>

<p>This is a great foundation, but so far we have no way of linking any new nodes. Let&rsquo;s fix that!</p>

<p>An <code>#append</code> method that adds a new node to the end of a list would be the best place to start. In order to implement this, we&rsquo;ll first work with our <code>LinkedList</code> class.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">LinkedList</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">head</span><span class="o">=</span><span class="kp">nil</span><span class="p">)</span><span class="o">&lt;</span><span class="sr">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;pre&gt;&lt;code&gt;@head = head</span>
</span><span class='line'><span class="sr">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;</span><span class="sr">/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt;  end&lt;/</span><span class="nb">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nb">p</span><span class="o">&gt;</span>  <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">&lt;</span><span class="sr">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;pre&gt;&lt;code&gt;if @head.nil?</span>
</span><span class='line'><span class="sr">  @head = ListNode.new(value)</span>
</span><span class='line'><span class="sr">else</span>
</span><span class='line'><span class="sr">  @head.append(value)</span>
</span><span class='line'><span class="sr">end</span>
</span><span class='line'><span class="sr">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;</span><span class="sr">/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt;  end</span>
</span><span class='line'><span class="sr">end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><code>LinkedList#append</code> first checks to see if the current list has a <code>@head</code> (which represents the first node). If it doesn&rsquo;t, it creates a new <code>ListNode</code> with the appropriate value and assigns it to <code>@head</code>. If <code>@head</code> already exists, an <code>#append</code> method is called on that specific node, essentially passing the appending responsibility to an instance of <code>ListNode</code>. Looks like <code>ListNode</code> is going to need its own <code>#append</code> method&hellip;</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">ListNode</span>
</span><span class='line'>  <span class="kp">attr_reader</span> <span class="ss">:value</span><span class="p">,</span> <span class="ss">:rest</span><span class="o">&lt;</span><span class="sr">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt;  def initialize(value, rest=nil)&lt;/</span><span class="nb">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="vi">@value</span> <span class="o">=</span> <span class="n">value</span>
</span><span class='line'><span class="vi">@rest</span> <span class="o">=</span> <span class="n">rest</span>
</span><span class='line'><span class="o">&lt;</span><span class="sr">/code&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nb">p</span><span class="o">&gt;</span>  <span class="k">end</span><span class="o">&lt;</span><span class="sr">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt;  def append(value)&lt;/</span><span class="nb">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">if</span> <span class="vi">@rest</span><span class="o">.</span><span class="n">nil?</span>
</span><span class='line'>  <span class="vi">@rest</span> <span class="o">=</span> <span class="no">ListNode</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</span><span class='line'><span class="k">else</span>
</span><span class='line'>  <span class="vi">@rest</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="o">&lt;</span><span class="sr">/code&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nb">p</span><span class="o">&gt;</span>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><code>ListNode#append</code> follows very similar logic. If <code>@rest</code> is <code>nil</code> (meaning the current node is the last one in the list), a new node is created and then referenced appropriately. Otherwise, the <code>#append</code> method is called recursively on <code>@rest</code>, meaning that each successive node will be checked until the end of the list is reached.</p>

<p>At this point, we can create a new linked list, and push nodes sequentially onto the end. This is really just the start of what a linked list of capable of, but I&rsquo;m going to allow you to experiment on your own from here. Some other essential methods you could try developing would be <code>#find</code>, <code>#delete</code>, <code>#prepend</code>, and <code>#insert_after</code>. If you&rsquo;re feeling adventurous, you could even try to implement <code>#map</code> and <code>#reduce</code>!</p>

<p>If you&rsquo;d like to see my implementation of these methods, <a href="https://gist.github.com/andrewjadams3/ebddee07291e004bc712">check out my linked list gist on GitHub</a>. Thanks again to <a href="https://twitter.com/dastels">Dave Astels</a> for getting me started!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Recursion]]></title>
    <link href="http://andrewada.ms/blog/2014/recursion/"/>
    <updated>2014-06-14T16:22:09-05:00</updated>
    <id>http://andrewada.ms/blog/2014/recursion</id>
    <content type="html"><![CDATA[<p>Recursion is a tricky subject. There are hundreds of blog posts strewn across the internet attempting to provide thorough explanations, often accompanied by seemingly simple snippets of code. No matter how elegant these explanations may be, most people find themselves working through example after example before finally (<em>maybe, kind of</em>) starting to get a hold on the subject. I&rsquo;ve decided (against my better judgment) to toss my hat into the ring, and highlight a few examples which helped me initially understand recursion. Hopefully they will help you experience a &lsquo;light bulb moment&rsquo; as they did for me.</p>

<!-- more -->


<p>Recursion in programming refers to a function/method which calls itself. It&rsquo;s that simple! Well, simple in theory. In practice, recursive functions can be difficult to design and interpret. In fact, recursive methods are often hard to follow precisely <em>because</em> they are deceptively simple. In just two or three lines, you can write a recursive method which does a whole hell of a lot of work.</p>

<p>Let&rsquo;s first look at how we can write a method which calls itself in Ruby:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">smaller</span><span class="p">(</span><span class="n">num</span><span class="p">)</span><span class="o">&lt;</span><span class="sr">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;pre&gt;&lt;code&gt;puts num</span>
</span><span class='line'><span class="sr">return smaller(num-1)</span>
</span><span class='line'><span class="sr">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;</span><span class="sr">/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt;end&lt;/</span><span class="nb">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nb">p</span><span class="o">&gt;</span><span class="n">smaller</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</span><span class='line'><span class="mi">3</span>
</span><span class='line'><span class="mi">2</span>
</span><span class='line'><span class="mi">1</span>
</span><span class='line'><span class="mi">0</span>
</span><span class='line'><span class="o">-</span><span class="mi">1</span>
</span><span class='line'><span class="o">&amp;</span><span class="n">hellip</span><span class="p">;</span><span class="n">forever</span><span class="o">&amp;</span><span class="n">hellip</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>In this example, you can see that the <code>smaller</code> method takes a number as an argument, prints that number, and then  returns a call to itself, passing <code>num-1</code> as an argument. In essence, the method is simply counting backwards from the original number.</p>

<p>This is great, we&rsquo;ve already created a recursive method! With one problem, however: it will never end. If you run this method as-is, it will never stop <code>puts</code>ing smaller and smaller numbers. To fix this, we need a base case.</p>

<p>A <strong>base case</strong> prevents a recursive method from calling itself when a certain condition is met. In the case of our <code>smaller</code> method, a logical base case could be when the number 0 is reached, or more specifically, when the number zero is passed as an argument. When this happens, we will simply have the method <code>return</code> rather than call itself again.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">smaller</span><span class="p">(</span><span class="n">num</span><span class="p">)</span><span class="o">&lt;</span><span class="sr">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;pre&gt;&lt;code&gt;puts num</span>
</span><span class='line'><span class="sr">if num == 0</span>
</span><span class='line'><span class="sr">    return</span>
</span><span class='line'><span class="sr">else</span>
</span><span class='line'><span class="sr">    return smaller(num-1)</span>
</span><span class='line'><span class="sr">end</span>
</span><span class='line'><span class="sr">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;</span><span class="sr">/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt;end&lt;/</span><span class="nb">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nb">p</span><span class="o">&gt;</span><span class="n">smaller</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</span><span class='line'><span class="mi">3</span>
</span><span class='line'><span class="mi">2</span>
</span><span class='line'><span class="mi">1</span>
</span><span class='line'><span class="mi">0</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Every time the <code>smaller</code> method runs, it calls itself with a smaller number. Eventually, the number 0 will be reached, and the method will end. There are, of course, shorter ways to write the code above, but the if/else statement illustrates very clearly what is happening.</p>

<p>At this point, you may be thinking, &ldquo;hey, that looks just like a loop!&rdquo; And you&rsquo;d be right! Anything that can be written recursively can also be refactored and written as a loop. In fact, depending on the problem being solved, a recursive function can eat up resources exponentially faster than its looped counterpart. However, recursive functions are often more elegant, and in many situations, simpler to implement.</p>

<p>Let&rsquo;s look at one, slightly more complex example:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">smaller_ary</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">array</span><span class="o">=[]</span><span class="p">)</span><span class="o">&lt;</span><span class="sr">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;pre&gt;&lt;code&gt;if num &amp;lt; 0</span>
</span><span class='line'><span class="sr">    return array</span>
</span><span class='line'><span class="sr">else</span>
</span><span class='line'><span class="sr">    array &amp;lt;&amp;lt; num</span>
</span><span class='line'><span class="sr">    return smaller_ary(num-1, array)</span>
</span><span class='line'><span class="sr">end</span>
</span><span class='line'><span class="sr">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;</span><span class="sr">/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt;end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Can you tell what this code is doing? And if so, what is the base case? What would happen if we called <code>smaller_ary(3)</code>? Let&rsquo;s find out!</p>

<p>First, let&rsquo;s find our base case:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">&lt;</span><span class="sr">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;pre&gt;&lt;code&gt;if num &amp;lt; 0</span>
</span><span class='line'><span class="sr">    return array</span>
</span><span class='line'><span class="sr">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;</span><span class="sr">/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>When the <code>num</code> argument is less than 0, the <code>array</code> argument will be returned. Although our previous example simply <code>return</code>ed, a base case doesn&rsquo;t necessarily need to return nothing. In fact, a base case is usually going to return <em>something</em>, either directly, or to be handed back to previous recursive calls.</p>

<p>If that was our base case, this would be our recursive call:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">&lt;</span><span class="sr">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;pre&gt;&lt;code&gt;else</span>
</span><span class='line'><span class="sr">    array &amp;lt;&amp;lt; num</span>
</span><span class='line'><span class="sr">    return smaller_ary(num-1, array)</span>
</span><span class='line'><span class="sr">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;</span><span class="sr">/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>When <code>num</code> is not smaller than zero (for example: 3), that number will first be appended onto the <code>array</code> argument. <em>(You may have noticed that when this method is called with only a number as an argument, the <code>array</code> argument will default to an empty array.)</em> Next, a call to <code>smaller_ary</code> will be returned, passing <code>num-1</code> and the newly-appended <code>array</code> as arguments. This call will send us right back to the top, only with a slightly smaller number. Each time the base case is not met, the number will be added to the array, and the method will be called with the next smallest number. When a number smaller than 0 is finally passed as an argument, the now-longer <code>array</code> will be returned.</p>

<p>So what happens when we call <code>smaller_ary(3)</code>? Here&rsquo;s a breakdown:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">smaller_ary</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">array</span><span class="o">=[]</span><span class="p">)</span><span class="o">&lt;</span><span class="sr">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;pre&gt;&lt;code&gt;if num &amp;lt; 0 # base case</span>
</span><span class='line'><span class="sr">    return array</span>
</span><span class='line'><span class="sr">else</span>
</span><span class='line'><span class="sr">    array &amp;lt;&amp;lt; num # append the number to the array</span>
</span><span class='line'><span class="sr">    return smaller_ary(num-1, array) # getting closer to the base case</span>
</span><span class='line'><span class="sr">end</span>
</span><span class='line'><span class="sr">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;</span><span class="sr">/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt;end&lt;/</span><span class="nb">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nb">p</span><span class="o">&gt;</span><span class="n">smaller_ary</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1">#=&gt; [3, 2, 1, 0]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>These examples have been great introductions to recursion, but they simply scratch the surface in terms of what can be accomplished. Most recursive methods go beyond emulating loops and divide complex problems into smaller, simpler, sub-problems. If you&rsquo;d like to learn more, check out <a href="http://www.theodinproject.com/ruby-programming/recursive-methods">this article from The Odin Project</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby: Enumerable#cycle]]></title>
    <link href="http://andrewada.ms/blog/2014/ruby-enumerable-number-cycle/"/>
    <updated>2014-05-11T18:56:08-05:00</updated>
    <id>http://andrewada.ms/blog/2014/ruby-enumerable-number-cycle</id>
    <content type="html"><![CDATA[<p>For this week&rsquo;s technical blog, I will be highlighting the uses of Enumberable#cycle in Ruby. After encountering this method, I became interested in learning how it worked! Luckily, it is fairly simple to use and understand.</p>

<p>Enumerable#cycle can be called on any enumerable object (such as a range, hash, or array) just like other familiar enumerable methods (like #each or #map). When called, a block will be run, either <em>n</em> times or forever (if no number is passed as an argument).</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">a</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="o">]</span>
</span><span class='line'><span class="n">b</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="n">b</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="n">c</span><span class="p">}</span>
</span><span class='line'><span class="n">a</span><span class="o">.</span><span class="n">cycle</span> <span class="p">{</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="nb">puts</span> <span class="n">x</span> <span class="p">}</span> <span class="c1"># ==&gt; print 1, 2, 3, 1, 2, 3&amp;hellip; forever.</span>
</span><span class='line'><span class="n">b</span><span class="o">.</span><span class="n">cycle</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="o">|</span> <span class="nb">puts</span> <span class="n">v</span> <span class="p">}</span> <span class="c1"># ==&gt; print a, b, c, a, b, c.</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Obviously, more complex code can be called within the block than what was just shown, but it serves as a good illustration. Be extremely careful calling #cycle without passing a number as an argument, as it will result in an infinite loop if you do not designate a break or stopping condition inside the loop (as I learned the hard way!)</p>
]]></content>
  </entry>
  
</feed>
